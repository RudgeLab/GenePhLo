import numpy as np
from loica import *

def build_network(N=1, gate_mismatch=1, scale=100, seed=0):
    net = GeneticNetwork()

    deg_rate = 1

    repressors = [Regulator(name=f'Rep{i}', degradation_rate=deg_rate) for i in range(N)]

    reporters = [Reporter(name=f'SFP{i}', color='red', degradation_rate=deg_rate) for i in range(2)]

    ahl = Supplement(name='IN')
    rec = Receiver(input=ahl, output=[repressors[0], reporters[0]], alpha=[0.125*scale,1.25*scale], K=0.5*scale, n=2)

    nots = [Hill1(input=repressors[i], output=repressors[i+1], alpha=[1*scale,0.1*scale], K=np.random.lognormal(sigma=gate_mismatch)*0.5*scale, n=4) for i in range(N-1)]

    not_out = Hill1(input=repressors[N-1], output=reporters[1], alpha=[1*scale,0.1*scale], K=np.random.lognormal(sigma=gate_mismatch)*0.5*scale, n=4)

    net.add_operators(nots)
    net.add_operator(not_out)
    net.add_operator(rec)
    net.add_reporters(reporters)
    net.add_regulators(repressors)
    
    return net, ahl


def growth_rate(t):
    return 0 # gompertz_growth_rate(t, 0.01, 1, 1, 0.5)

def biomass(t):
    return 1 # gompertz(t, 0.01, 1, 1, 0.5)

metab = SimulatedMetabolism('no growth', biomass, growth_rate)

def prof_input(period, phase=0):
    def f(t):
        p = period
        return ((t-phase*0.5*p/np.pi)%p)/p < 1/2
    return f
    
def define_sample(net, ahl, phase_based=True, ref_period=200, scale=100, logic=0):
    sample = Sample(genetic_network=net, 
                        metabolism=metab)

    if phase_based:
        prof = prof_input(ref_period, (1-logic)*np.pi)
        conc = scale
    else:
        prof = None
        conc = scale*logic

    # Input
    sample.set_supplement(ahl, conc, profile=prof)
    return sample

from scipy.signal import correlate, correlation_lags

def compute_phases(meas, interval, ref_period, plot=False):
    phases = np.zeros((len(net.reporters),))
    for i in range(len(net.reporters)):
        ref_sig = meas[meas.Signal=='SFP0']
        m1 = ref_sig[ref_sig.Time>ref_period].sort_values('Time').Measurement.values
        sig = meas[meas.Signal==f'SFP{i}']
        m2 = sig[sig.Time>ref_period].sort_values('Time').Measurement.values
        c = correlate(m1 - m1.mean(), m2 - m2.mean())
        lags = correlation_lags(len(m1), len(m2))
        phase_diff = lags[np.argmax(c)] * interval / ref_period * 360
        phase_diff = phase_diff % 360 
        if plot:
            plt.figure(figsize=(6,2))
            #plt.plot(lags[int(len(lags)/2):], c[int(len(c)/2):])
            plt.plot(lags * interval / ref_period * 360, c)
            plt.plot(phase_diff, c[np.argmax(c)], 'r*')
            plt.xticks([-360, -180, 0, 180, 360])
            plt.yticks([])
        
        phase_diff = abs(phase_diff)
        if phase_diff > 180:
            phase_diff = 360 - phase_diff
        phases[i] = phase_diff

    return phases

import sys
if len(sys.argv)>=2:
    seeds = sys.argv[1:]
else:
    seeds = [0]


interval = 0.24
ref_period = 120
scale = 100

err0_phase_list = []
err1_phase_list = []
err0_level_list = []
err1_level_list = []
mismatch = 1
Ns = [1, 3, 5, 7, 9] #range(1, 6)
for N in Ns:
    errs0_phase = 0
    errs1_phase = 0
    errs0_level = 0
    errs1_level = 0
    for seed in range(seeds):
        print(f'N={N}, replicate {rep+1}')
        net, ahl = build_network(N=N, gate_mismatch=mismatch, scale=scale, seed=seed)
        
        # Phase-based
        sample0 = define_sample(net, ahl, phase_based=True, ref_period=ref_period, scale=scale, logic=0)
        sample1 = define_sample(net, ahl, phase_based=True, ref_period=ref_period, scale=scale, logic=1)
        assay = Assay([sample0, sample1], 
                      n_measurements=int(2*ref_period/interval), 
                      interval=interval,
                      name='Loica phase logic',
                      description='Simulated phase logic circuit generated by loica'
                     )
        assay.run(stochastic=True)
        meas = assay.measurements
        phases0 = compute_phases(meas[meas.Sample==0], interval, ref_period, plot=False)
        phases1 = compute_phases(meas[meas.Sample==1], interval, ref_period, plot=False)
        print(phases0, phases1)
        if phases0[1]<90:
            errs0_phase += 1
        if phases1[1]<90:
            errs1_phase += 1
            
        # Level-based
        sample0 = define_sample(net, ahl, phase_based=False, scale=scale, logic=0)
        sample1 = define_sample(net, ahl, phase_based=False, scale=scale, logic=1)
        assay = Assay([sample0, sample1], 
                      n_measurements=int(2*ref_period/interval), 
                      interval=interval,
                      name='Loica phase logic',
                      description='Simulated phase logic circuit generated by loica'
                     )
        assay.run(stochastic=True)
        meas = assay.measurements
        level0 = meas[meas.Signal=='SFP1'][meas.Time>ref_period][meas.Sample==0].Measurement
        level1 = meas[meas.Signal=='SFP1'][meas.Time>ref_period][meas.Sample==1].Measurement

        #print(level0, level1)
        if N%2==0:
            if level0.mean()>=scale/2:
                errs0_level += 1
                print(f"Error mean(level0) = {level0.mean()}")
            if level1.mean()<scale/2:
                errs1_level += 1            
                print(f"Error mean(level1) = {level1.mean()}")
        else:
            if level0.mean()<scale/2:
                errs0_level += 1
                print(f"Error mean(level0) = {level0.mean()}")
            if level1.mean()>=scale/2:
                errs1_level += 1
                print(f"Error mean(level1) = {level1.mean()}")
            
    err0_phase_list.append(errs0_phase)        
    err1_phase_list.append(errs1_phase)
    err0_level_list.append(errs0_level)        
    err1_level_list.append(errs1_level)
    
fout = open(f'result_seeds_{seeds}.csv', 'wt')
fout.write('N, seed, err0_phase, err1_phase, err0_level, err1_level\n')
for i in range(len(Ns)):
    fout.write(f'{Ns[i]}, {seeds[i]}, {err0_phase_list[i]}, {err1_phase_list[i]}, {err0_level_list[i]}, {err1_level_list[i]}\n')
fout.close()


