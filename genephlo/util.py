from loica import *
import numpy as np
import pandas as pd
from scipy.signal import correlate, correlation_lags
import matplotlib.pyplot as plt

def find_downstream_ops(op, ops):
    outputs = op.output
    if type(outputs)!=list:
        outputs = [outputs]
    downstream_ops = []
    for out in outputs:
        for op2 in ops:
            op_inputs = op2.input
            if type(op_inputs)!=list:
                op_inputs = [op_inputs]
            if out in op_inputs:
                downstream_ops.append((out,op,op2))
    return downstream_ops

def phi1(x, a, b, n):
    return (a + b * x**(n/2)) / (1 + x**(n/2))

def phi2(x, a, b, n):
    return (a + b * x**(-n/2)) / (1 + x**(-n/2))

def optimize(net, d, alpha0):
    regs = net.regulators
    ops = net.operators
    recs = [op for op in ops if type(op)==Receiver]
    # Set up a list in each operator to store upstream gate output dynamic ranges
    for op in ops:
        if type(op)==Hill1:
            op.din = -1
            op.dout = -1
        elif type(op)==Sum:
            op.din = np.zeros((3,)) - 1
            op.dout = -1

    # Start from receivers
    downstream_ops = []
    for rec in recs:
        # Set optimal parameters assuming large input dynamic range
        rec.K = 1
        rec.Kout = alpha0 / np.sqrt(d)
        rec.din = d
        rec.dout = d
        rec.alpha = [alpha0/d, alpha0]
        # Find downstream operators
        downstream_ops += find_downstream_ops(rec, ops)
        
    while len(downstream_ops)!=0:
        new_downstream_ops = []
        # Set optimal parameters for downstream ops 
        for reg,upop,dop in downstream_ops:
            new_downstream_ops += find_downstream_ops(dop, ops)
            if type(dop)==Hill1:
                if upop.dout!=-1 and dop.dout==-1:
                    dop.din = upop.dout
                    pon = phi2(dop.din, 1, 1/d, dop.n)
                    poff = phi1(dop.din, 1, 1/d, dop.n)
                    dop.Kout = alpha0 * np.sqrt(pon * poff)
                    dop.K = upop.Kout
                    dop.alpha = [alpha0, alpha0/d]
                    dop.dout = pon/poff
            elif type(dop)==Sum:
                idx = np.where(np.array(dop.input)==reg)
                idx = idx[0][0]
                if upop.dout!=-1:
                    dop.din[idx] = upop.dout
                    dop.alpha[idx] = [alpha0/d, alpha0]
                    dop.K[idx] = upop.Kout
                if not np.any(dop.din==-1) and dop.dout==-1:
                    p1A = phi1(dop.din[0], 1/d, 1, dop.n[idx])
                    p1B = phi1(dop.din[1], 1/d, 1, dop.n[idx])
                    p1C = phi1(dop.din[2], 1/d, 1, dop.n[idx])
                    p1s = np.sort([p1A, p1B, p1C])
                    p2A = phi2(dop.din[0], 1/d, 1, dop.n[idx])
                    p2B = phi2(dop.din[1], 1/d, 1, dop.n[idx])
                    p2C = phi2(dop.din[2], 1/d, 1, dop.n[idx])
                    p2s = np.sort([p2A, p2B, p2C])
                    
                    pon = p1s[:2].sum() + p2s[-1]
                    poff = p1s[-1] + p2s[:2].sum() 
                    dop.Kout = alpha0 * np.sqrt( pon * poff )
                    dop.dout = pon / poff
        downstream_ops = new_downstream_ops

def compute_phases(net, meas, prof, interval, ref_period, plot=False):
    n_reporters = len(net.reporters)
    print(n_reporters)
    phases =  np.zeros((n_reporters,))
    lags = []
    corrs = []
    T = meas[meas.Time>ref_period].sort_values('Time').Time.unique()
    for i in range(n_reporters):
        #ref_sig = meas[meas.Signal=='SFP0']
        #m1 = ref_sig[ref_sig.Time>ref_period].sort_values('Time').Measurement.values
        m1 = prof(T)
        sig = meas[meas.Signal==f'SFP{i}']
        m2 = sig[sig.Time>ref_period].sort_values('Time').Measurement.values
        c = correlate((m1 - m1.mean()) / m1.std(), (m2 - m2.mean()) / m2.std()) / len(m1)
        lag = correlation_lags(len(m1), len(m2))
        phase_diff = lag[np.argmax(c)] * interval / ref_period * 360
        phase_diff = phase_diff % 360 
        if plot:
            plt.figure(figsize=(6,2))
            plt.plot(lag * interval / ref_period * 360, c)
            plt.plot(phase_diff, c[np.argmax(c)], 'r*')
            plt.xticks([-360, -180, 0, 180, 360])
            plt.yticks([])
        
        phase_diff = abs(phase_diff)
        if phase_diff > 180:
            phase_diff = 360 - phase_diff
        phases[i] = phase_diff

        lags.append(lag)
        corrs.append(c)

    return phases, lags, corrs

def run_assay(sample, ref_period, interval, stochastic=True):
    assay = Assay([sample], 
                  n_measurements=int(ref_period*2/interval), 
                  interval=interval,
                  name='Loica phase logic',
                  description='Simulated phase logic circuit generated by loica'
                 )
    assay.run(stochastic=stochastic)
    return assay.measurements

